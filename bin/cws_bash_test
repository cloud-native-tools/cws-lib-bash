#!/usr/bin/env bash

# CWS-Lib-Bash Test Runner & Framework
# 
# This script serves two purposes:
# 1. A test runner that executes test scripts in the test/ directory
# 2. A test framework library that provides assertion functions when sourced
#
# Usage: 
#   ./bin/cws_bash_test [test_name]   # Run tests
#   source ./bin/cws_bash_test        # Load framework in a test script

# -----------------------------------------------------------------------------
# Framework Configuration & Globals
# -----------------------------------------------------------------------------

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
CLEAR='\033[0m'

# Test counters (reset when running a suite)
TEST_TOTAL=0
TEST_PASSED=0
TEST_FAILED=0

# -----------------------------------------------------------------------------
# Logging Helper Functions
# -----------------------------------------------------------------------------

function log_header() {
  echo -e "\n${BLUE}=== $1 ===${CLEAR}"
}

function log_info() {
  echo -e "${CYAN}[INFO]${CLEAR} $*"
}

function log_success() {
  echo -e "${GREEN}[PASS]${CLEAR} $*"
}

function log_error() {
  echo -e "${RED}[FAIL]${CLEAR} $*"
}

function log_warn() {
  echo -e "${YELLOW}[WARN]${CLEAR} $*"
}

# -----------------------------------------------------------------------------
# Assertion Functions
# -----------------------------------------------------------------------------

# Assert two values are equal
# Usage: assert_eq <expected> <actual> [message]
function assert_eq() {
  local expected="$1"
  local actual="$2"
  local msg="${3:-Values should be equal}"
  
  ((TEST_TOTAL++))
  if [[ "$expected" == "$actual" ]]; then
    log_success "$msg"
    ((TEST_PASSED++))
    return 0
  else
    log_error "$msg"
    echo -e "  Expected: '${expected}'"
    echo -e "  Actual:   '${actual}'"
    ((TEST_FAILED++))
    return 1
  fi
}

# Assert two values are NOT equal
# Usage: assert_neq <expected> <actual> [message]
function assert_neq() {
  local expected="$1"
  local actual="$2"
  local msg="${3:-Values should not be equal}"
  
  ((TEST_TOTAL++))
  if [[ "$expected" != "$actual" ]]; then
    log_success "$msg"
    ((TEST_PASSED++))
    return 0
  else
    log_error "$msg"
    echo -e "  Value: '${actual}'"
    ((TEST_FAILED++))
    return 1
  fi
}

# Assert condition is true
# Usage: assert_true <condition> [message]
# Example: assert_true "[[ 1 -eq 1 ]]" "Math works"
function assert_true() {
  local condition="$1"
  local msg="${2:-Condition should be true}"
  
  ((TEST_TOTAL++))
  if eval "$condition"; then
    log_success "$msg"
    ((TEST_PASSED++))
    return 0
  else
    log_error "$msg"
    echo -e "  Condition failed: $condition"
    ((TEST_FAILED++))
    return 1
  fi
}

# Assert string contains substring
# Usage: assert_contains <haystack> <needle> [message]
function assert_contains() {
  local haystack="$1"
  local needle="$2"
  local msg="${3:-String should contain substring}"
  
  ((TEST_TOTAL++))
  if [[ "$haystack" == *"$needle"* ]]; then
    log_success "$msg"
    ((TEST_PASSED++))
    return 0
  else
    log_error "$msg"
    echo -e "  String:   '$haystack'"
    echo -e "  Expected: '$needle'"
    ((TEST_FAILED++))
    return 1
  fi
}

# Assert previous command succeeded (exit code 0)
# Usage: assert_success [message]
function assert_success() {
  local exit_code=$?
  local msg="${1:-Command should succeed}"
  
  ((TEST_TOTAL++))
  if [[ $exit_code -eq 0 ]]; then
    log_success "$msg"
    ((TEST_PASSED++))
    return 0
  else
    log_error "$msg"
    echo -e "  Exit code: $exit_code"
    ((TEST_FAILED++))
    return 1
  fi
}

# Assert previous command failed (exit code != 0)
# Usage: assert_fail [message]
function assert_fail() {
  local exit_code=$?
  local msg="${1:-Command should fail}"
  
  ((TEST_TOTAL++))
  if [[ $exit_code -ne 0 ]]; then
    log_success "$msg"
    ((TEST_PASSED++))
    return 0
  else
    log_error "$msg"
    echo -e "  Exit code: $exit_code (expected non-zero)"
    ((TEST_FAILED++))
    return 1
  fi
}

# Print test summary
function print_summary() {
  echo "========================================"
  echo "Test Summary:"
  echo "  Total:  ${TEST_TOTAL}"
  echo "  Passed: ${TEST_PASSED}"
  echo "  Failed: ${TEST_FAILED}"
  echo "========================================"
  
  if [[ ${TEST_FAILED} -eq 0 ]]; then
    return 0
  else
    return 1
  fi
}

# -----------------------------------------------------------------------------
# Runner Logic (Only executed if script is run directly)
# -----------------------------------------------------------------------------

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  set -u # Don't use set -e, we want to catch failures
  
  # Get the script directory
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  PROJECT_ROOT="$(dirname "${SCRIPT_DIR}")"
  TEST_DIR="${PROJECT_ROOT}/test"
  
  # Export framework functions so they are available in subshells
  export -f log_header log_info log_success log_error log_warn
  export -f assert_eq assert_neq assert_true assert_contains assert_success assert_fail
  
  function usage() {
    echo "Usage: $0 [test_name]"
    echo ""
    echo "Available tests:"
    if [ -d "${TEST_DIR}" ]; then
      for test_file in "${TEST_DIR}"/test_*.sh; do
        if [ -f "${test_file}" ]; then
          local test_name=$(basename "${test_file}" .sh)
          echo "  ${test_name}"
        fi
      done
    else
      echo "  No test directory found at ${TEST_DIR}"
    fi
    echo ""
    echo "Examples:"
    echo "  $0                # Run all tests"
    echo "  $0 test_env       # Run only environment variable tests"
  }

  function run_test_file() {
    local test_file=$1
    local test_name=$(basename "${test_file}" .sh)
    
    log_header "Running ${test_name}"
    
    if [ ! -f "${test_file}" ]; then
      log_error "Test file not found: ${test_file}"
      return 1
    fi
    
    if [ ! -x "${test_file}" ]; then
      chmod +x "${test_file}"
    fi
    
    # Run the test in a subshell
    # We use a wrapper to capture the exit code properly
    (
      # Source the framework again inside the subshell to ensure variables are reset/available
      # if the test script doesn't source it.
      # However, since we are running the script, we can't easily force it to source us.
      # But we exported the functions, so they should be available.
      "${test_file}"
    )
    local status=$?
    
    if [ $status -eq 0 ]; then
      return 0
    else
      return 1
    fi
  }

  function run_all_tests() {
    local total_files=0
    local passed_files=0
    local failed_files=0
    
    log_info "Running all tests in ${TEST_DIR}"
    
    if [ ! -d "${TEST_DIR}" ]; then
      log_error "Test directory not found: ${TEST_DIR}"
      exit 1
    fi
    
    for test_file in "${TEST_DIR}"/test_*.sh; do
      if [ -f "${test_file}" ]; then
        ((total_files++))
        if run_test_file "${test_file}"; then
          ((passed_files++))
        else
          ((failed_files++))
        fi
      fi
    done
    
    echo ""
    echo "========================================"
    echo "Suite Summary:"
    echo "  Total files:  ${total_files}"
    echo "  Passed files: ${passed_files}"
    echo "  Failed files: ${failed_files}"
    echo "========================================"
    
    if [ ${failed_files} -eq 0 ]; then
      log_success "All test files passed!"
      return 0
    else
      log_error "${failed_files} test file(s) failed!"
      return 1
    fi
  }

  function main() {
    # Change to project root directory
    cd "${PROJECT_ROOT}"
    
    case ${1:-""} in
      -h|--help|help)
        usage
        exit 0
        ;;
      "")
        # Run all tests
        run_all_tests
        ;;
      *)
        # Run specific test
        local test_name="$1"
        local test_file="${TEST_DIR}/${test_name}.sh"
        
        if [[ ! "${test_name}" =~ ^test_ ]]; then
          test_file="${TEST_DIR}/test_${test_name}.sh"
        fi
        
        run_test_file "${test_file}"
        ;;
    esac
  }

  # Run main function with all arguments
  main "$@"
fi
